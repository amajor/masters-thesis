% =============================================================================
% =  My Idea (2 pages)
% =============================================================================

\section{The Impact of Structural Quality} \label{sectionMyIdea}

% --- Understand Software Maintenance -----------------------------------------
\subsection{Software Maintenance} \label{subSoftwareMaintenance}

The structural quality of a software system will impact the software evolution. Similarly, as a project evolves, it is likely to degrade, as developers often make changes quickly and in ways that the original design did not anticipate \cite{martin:2000}. However, if the project has poor structural quality, its ability to evolve will be minimized, and the software system will eventually ``die off.''

There is much planning involved in all software creation projects in what the product will be, will do, who it is for, and so on. One of the things that should also be on the planning list is long-term maintenance and growth. So how do we build a thing that will be easier to add features to down the road?

Let us define maintainability in the context of software. For example, it would be easy to maintain if a system is easy to debug and easy to add new features. These new features are generally considered minor features and may often be reported as bugs by users when, in reality, they are looking for functionality enhancements \cite{wiki:software-maintenance}.

\vspace{0.25cm}
\begin{displayquote}
  ``Software maintenance in software engineering is the modification of a software product after delivery to correct faults, to improve performance or other attributes.'' \cite{wiki:software-maintenance}
\end{displayquote}
\vspace{0.25cm}

It may be easier to understand what characteristics define a system with poor maintainability. These types of systems will have poor code quality, leading to defects. For instance, there could be undetected vulnerabilities or exposures, or it may be that the system is overly complex. In addition to the complexity, it could be hard to read due to the poor naming of dead (unused) code throughout the source code.

A project is known to have good maintainability when there is an enforced set of clean and consistent standards for the code. These standards often involve having human-readable names for functions, methods, and variables. Minimize any complex code and methods should be small and focus on a single thing. Parts of the system are decoupled and organized, making it easy to work on different parts with low impact on unrelated parts. In other words, the code is DRY (\underline{D}on't \underline{R}epeat \underline{Y}ourself \textemdash there is limited redundancy in the code), unused code has been removed, and there is a level of documentation that supports an easy understanding of the system.

% \todo{TODO: Anything about SOLID and when too many files are being touched? \cite{martin:2000}}

Why should we care about whether the code is maintainable? There is an assumption that the majority of cost over the lifetime of a project falls under maintainability. Fred Brooks, in his book ``The Mythical Man-Month'' (1975), even claimed that over 90\% of the costs for a typical software system come up in the maintenance phase \cite{brooks:mythical}. In 1977, Meir M. Lehman noted that maintenance accounts for 70\% of a program budget, with 30\% spent on development. In 1993, there was another observation that the development of a typical project uses only 20-40\% of the resources (money, time, effort), with 60-70\% used for maintenance activities \cite{ieee:1219}.

Once the bulk of the system is off the ground and live worldwide, how well the team can improve the system with new features and fix bugs, even working on different parts in parallel, can be impacted by its maintainability. Any successful piece of software will inevitably need to be maintained.

% --- Understand Software Evolution -------------------------------------------
\subsection{Software Evolution} \label{subSoftwareEvolution}

There is a distinction to be made between \textbf{software maintenance} and \textbf{software evolution}. From here, we will refer to software maintenance as bug resolution and minor functional improvements. In other words, we can consider this routine maintenance when we must fix a broken route in the application or provide a subtle enhancement to the user experience. However, when we look at upgrades, adaptations to the changing and growing needs of the user, or migrating the system to new technology, we can refer to this as the evolution of the software.

The evolution of software can result from new laws that have come into being. As technology changes, governing bodies must continually revisit data collection and information sharing policies. As a result, changes in technology and laws may lead to adaptations in the software systems.

It is also fair to say that systems will change because we can never fully determine a user's needs at the start of a project. Thus, it would be safe to say that users' needs will change over time. However, the changing user needs can lead to a never-ending project that will always need some form of enhancement.

Meir ``Manny'' Lehman and László ``Les'' Bélády contributed to a list of laws involving software evolution known as Lehman's Laws that describe a balance between forces that drive new developments while also slowing progress. These laws apply to programs written to perform some real-world activity. The software environment and the software's behavior are linked; additionally, this program category assumes that the program needs to adapt to varying requirements and circumstances in that environment. Eight laws were created and are listed below. \cite{wiki:lehmans-laws}

% \todo{TODO: Read and reference ``An Empirical Study of Lehman's Law on Software Quality Evolution'' \cite{yu:2013}}.

\vspace{0.25cm}
\begin{enumerate}
    % "Continuing Change" — an E-type system must be continually adapted or it becomes progressively less satisfactory.
    \item \textbf{Continuing Change} \textit{(1974)}
    
    % "Increasing Complexity" — as an E-type system evolves, its complexity increases unless work is done to maintain or reduce it.
    \item \textbf{Increasing Complexity} \textit{(1974)}

    % "Self Regulation" — E-type system evolution processes are self-regulating with the distribution of product and process measures close to normal.
    \item \textbf{Self Regulation} \textit{(1974)}

    % "Conservation of Organisational Stability (invariant work rate)" — the average effective global activity rate in an evolving E-type system is invariant over the product's lifetime.
    \item \textbf{Conservation of Organisational Stability} \textit{(1978)}

    % "Conservation of Familiarity" — as an E-type system evolves, all associated with it, developers, sales personnel, and users, for example, must maintain mastery of its content and behavior to achieve satisfactory evolution. Excessive growth diminishes that mastery. Hence the average incremental growth remains invariant as the system evolves.
    \item \textbf{Conservation of Familiarity} \textit{(1978)}

    % "Continuing Growth" — the functional content of an E-type system must be continually increased to maintain user satisfaction over its lifetime.
    \item \textbf{Continuing Growth} \textit{(1991)}

    % "Declining Quality" — the quality of an E-type system will appear to be declining unless it is rigorously maintained and adapted to operational environment changes.
    \item \textbf{Declining Quality} \textit{(1996)}

    % "Feedback System" (first stated 1974, formalised as law 1996) — E-type evolution processes constitute multi-level, multi-loop, multi-agent feedback systems and must be treated as such to achieve significant improvement over any reasonable base.
    \item \textbf{Feedback System} \textit{(1996)}
\end{enumerate}
\vspace{0.25cm}

The first law, ``Continuing Change,'' tells us that it will become progressively less satisfactory if a system does not adapt. The second, ``Increasing Complexity,'' explains that as a system evolves, the complexity will increase unless there is work done to maintain or reduce complexity. Increased complexity can be due to the added code volume from new features or an increasing number of developers editing the code. Unless we actively address this phenomenon of increased complexity during changes, it can impact the maintainability (and the ability of a project to continue evolving) in the future.

Lehman's fifth law, ``Conservation of Familiarity,'' explains how the average incremental growth does not change over time as a system evolves. The people interacting with the system, such as the developers, business persons, or users, must continue using and working within the system at the same ``level of mastery.'' If the system grows and changes excessively, the mastery will drop, slowing down the next set of changes. Slower deployment of additional changes could be because the source code or architecture has become more complex (impacting the developers' ability to adapt and enhance the system) or because the user features have changed. Namely, the system audience needs time to master the new interfaces or tools. However, the average incremental growth will remain steady because of this natural ``slow-down'' for excessive change. To illustrate, we can see a simplified visual in ``Fig.~\ref{figConservationOfFamiliarity}'' showing that when the number of changes spikes (excessive growth in a system), it will be followed by an iteration of fewer changes. Over time, excessive growth followed by fewer changes leads to a nearly consistent average of incremental growth (the thick, horizontal line).

\begin{figure}[ht]
    \centerline{
        \includegraphics[width=\columnwidth]{Changes-vs-Time}
    }
    \caption{A simplified visual of Lehman's fifth law, ``Conservation of Familiarity.''}
    \label{figConservationOfFamiliarity}
\end{figure}

In Lehman's sixth law, ``Continuing Growth,'' we see that the system user's satisfaction will drop without continually increasing the functional content. Along with a similar idea, the law about ``Declining Quality'' states that if the operational environment for the system does not change, the system's quality will appear to decline. Yu and Mishra performed focused research on supporting Lehman's Laws, especially in the case of the seventh law about declining quality. They did this by defining a metric for software quality and reviewing the bug history, growth of the size, complexity, and quality of two large open-source systems \cite{yu:2013}. Therefore, we must continue adapting for even the appearance of the maintained quality of a system.

With many characteristics surrounding software evolution, we benefit from the Internet, which has positively improved the experience. Two common resources currently available to developers have impacted software evolution \cite{wiki:software-evolution}:

\vspace{0.25cm}
\begin{enumerate}
    \item The rapid growth of the World Wide Web and Internet Resources make it easier for users and engineers to find related information.
    \item Open source development where anybody could download the source codes and modify it has enabled fast and parallel evolution (through forks).
\end{enumerate}
\vspace{0.25cm}

These two suggestions are very evident in modern development. In other words, a developer may regularly use resources like StackOverflow to find solutions to problems and use open-source tools that the developer and their team can contribute to or adjust to their specific needs.

\subsection{Measuring Maintainability} \label{subMeasureMaintainability}

Despite the nuanced differences between \textit{maintainability} and \textit{evolution}, the two characteristics run parallel to each other. It will be easier to evolve if a system is easy to maintain. If we can measure our system's maintainability, we can also determine if our system is in a good position to continue evolving to meet our future needs.

\vspace{0.25cm}
\begin{displayquote}
``The unit cost of change must initially be made as low as possible and its growth, as the system ages, minimized. Programs must be made more alterable, and the alterability maintained throughout their lifetime. The change process itself must be planned and controlled.'' \cite{lehman:1980}
\end{displayquote}
\vspace{0.25cm}

Several tools attempt to provide some value around these ideas. In this paper, we will focus on the metrics that Pylint and Radon provide, specifically looking into their Refactor score of Pylint and the Maintainability Index from Radon.

We will look at many open-source Python systems using Radon and Pylint, then attempt to correlate the data from the scores to the level of ease in adding new features to the system.
